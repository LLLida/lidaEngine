#version 450
#extension GL_GOOGLE_include_directive : enable

layout (local_size_x = 64, local_size_y = 1) in;

#include "common.h"

#define NEW_BACKFACE_CULLING 1

// stride: 48 bytes
struct Draw_Data {
  float half_size_x;
  float half_size_y;
  float half_size_z;
  uint first_vertex;
  uint first_instance;
  uint vertex_count0;
  uint vertex_count1;
  uint vertex_count2;
  uint vertex_count3;
  uint vertex_count4;
  uint vertex_count5;
  uint cull_mask;
};

// stride: 32 bytes
struct Transform {
  quat rotation;
  vec3 position;
  float scale;
};

// stride: 32 bytes
struct Draw_Command {
  uint index_count;
  uint instance_count;
  uint first_index;
  uint vertex_offset;
  uint first_instance;
};

// stride: 32 bytes
struct Vertex_Count {
  uint count0;
  uint count1;
  uint count2;
  uint count3;
  uint count4;
  float udata1;
  float udata2;
  float udata3;
  // float obb2_x;
  // float obb2_y;
  // float obb2_z;
};

// stride: 16 bytes
struct Draw_Count {
  uint count;
};

// storage buffer
layout (std140, set = 0, binding = 0) readonly buffer Storage_Buffer {
  Draw_Data in_draws[];
};

layout (std140, set = 0, binding = 1) readonly buffer Transform_Buffer {
  Transform transforms[];
};

layout (std140, set = 0, binding = 2) writeonly buffer Indirect_Buffer {
  Draw_Command out_draws[];
};

// TODO: move this to vox_cull_persp.comp
layout (std140, set = 0, binding = 3) writeonly buffer Vertex_Buffer {
  Vertex_Count vertex_counts[];
};

layout (std140, set = 0, binding = 4) writeonly buffer Draw_Counts {
  Draw_Count draw_count[];
};

PUSH_CONSTANT Pass_Info {
#if NEW_BACKFACE_CULLING
  mat4 projview_matrix;
  uint cull_mask;
#else
  vec3 cull_front;
  uint cull_mask;
  vec3 camera_position;
#endif
  uint pass_id;
  uint draw_offset;
  uint in_offset;
  uint num_draws;
};

const vec3 vox_normals[6] = {
  {-1.0,  0.0,  0.0},
  { 1.0,  0.0,  0.0},
  { 0.0, -1.0,  0.0},
  { 0.0,  1.0,  0.0},
  { 0.0,  0.0, -1.0},
  { 0.0,  0.0,  1.0}
};

void main() {
  uint draw_index = gl_GlobalInvocationID.x;

  // check if we're out of bounds
  if (draw_index >= num_draws)
    return;

  Draw_Data d = in_draws[draw_index + in_offset];

  Transform transform = transforms[d.first_instance];

  uint vertex_count[6] = {
    d.vertex_count0,
    d.vertex_count1,
    d.vertex_count2,
    d.vertex_count3,
    d.vertex_count4,
    d.vertex_count5,
  };

  uint vertex_offset = d.first_vertex;
  uint out_id = (draw_index + draw_offset) * 3;

  if ((d.cull_mask & cull_mask) == 0) {
    return;
  }
#if NEW_BACKFACE_CULLING
  // calculate OBB
  vec3 box[3];
  box[0] = rotate(vec3(d.half_size_x, 0.0, 0.0), transform.rotation);
  box[1] = rotate(vec3(0.0, d.half_size_y, 0.0), transform.rotation);
  box[2] = rotate(vec3(0.0, 0.0, d.half_size_z), transform.rotation);
  const vec3 muls[8] = {
    vec3( -1.0, -1.0, -1.0 ),
    vec3( -1.0, -1.0, 1.0 ),
    vec3( -1.0, 1.0, -1.0 ),
    vec3( -1.0, 1.0, 1.0 ),
    vec3( 1.0, -1.0, -1.0 ),
    vec3( 1.0, -1.0, 1.0 ),
    vec3( 1.0, 1.0, -1.0 ),
    vec3( 1.0, 1.0, 1.0 ),
  };
  vec3 obb_corners[8];
  for (int i = 0; i < 8; i++) {
    vec3 basis[3];
    basis[0] = box[0] * muls[i].x * transform.scale;
    basis[1] = box[1] * muls[i].y * transform.scale;
    basis[2] = box[2] * muls[i].z * transform.scale;
    // position in global space
    obb_corners[i].x = basis[0].x + basis[1].x + basis[2].x + transform.position.x;
    obb_corners[i].y = basis[0].y + basis[1].y + basis[2].y + transform.position.y;
    obb_corners[i].z = basis[0].z + basis[1].z + basis[2].z + transform.position.z;
    // position on screen
    vec4 ndc = projview_matrix * vec4(obb_corners[i], 1.0);
    // do perspective division
    obb_corners[i] = ndc.xyz / ndc.w;
  }
  const uint face_indices[18] = {
    0, 1, 3, // -x
    4, 5, 7, // +x
    0, 1, 5, // -y
    2, 3, 7, // +y
    0, 2, 6, // -z
    1, 3, 7, // +z
  };
  // do backface culling
#if 1
  for (int i = 0; i < 3; i++) {
    vec3 a = obb_corners[face_indices[i*6]];
    vec3 b = obb_corners[face_indices[i*6+1]];
    vec3 c = obb_corners[face_indices[i*6+2]];
    vec3 dir1 = b-a;
    vec3 dir2 = c-a;
    vec3 normal1 = cross(dir1, dir2);
    a = obb_corners[face_indices[i*6+3]];
    b = obb_corners[face_indices[i*6+4]];
    c = obb_corners[face_indices[i*6+5]];
    dir1 = b-a;
    dir2 = c-a;
    vec3 normal2 = cross(dir1, dir2);
    if (normal1.z < 0.0 ||
        normal2.z > 0.0) {
      // add draw
      uint id = atomicAdd(draw_count[pass_id].count, 1);
      out_draws[draw_offset * 5 + id].index_count = vertex_count[2*i] * 3 / 2;
      out_draws[draw_offset * 5 + id].instance_count = 1;
      out_draws[draw_offset * 5 + id].first_index = vertex_offset * 3 / 2;
      out_draws[draw_offset * 5 + id].vertex_offset = d.first_vertex;
      out_draws[draw_offset * 5 + id].first_instance = d.first_instance;
    }
    vertex_offset += vertex_count[2*i];
    if (normal1.z > 0.0 ||
        normal2.z < 0.0) {
      uint id = atomicAdd(draw_count[pass_id].count, 1);
      out_draws[draw_offset * 5 + id].index_count = vertex_count[2*i+1] * 3 / 2;
      out_draws[draw_offset * 5 + id].instance_count = 1;
      out_draws[draw_offset * 5 + id].first_index = vertex_offset * 3 / 2;
      out_draws[draw_offset * 5 + id].vertex_offset = d.first_vertex;
      out_draws[draw_offset * 5 + id].first_instance = d.first_instance;
    }
    vertex_offset += vertex_count[2*i+1];
  }
#else
  float sizes[3] = { d.half_size_x*transform.scale, d.half_size_y*transform.scale, d.half_size_y*transform.scale };
  for (int i = 0; i < 3; i++) {
    vec3 a = obb_corners[face_indices[i*6]] + sizes[i];
    vec3 b = obb_corners[face_indices[i*6+1]] + sizes[i];
    vec3 c = obb_corners[face_indices[i*6+2]] + sizes[i];
    vec3 dir1 = b-a;
    vec3 dir2 = c-a;
    vec3 normal = cross(dir1, dir2);
    if (normal.z < 0.0) {
      // add draw
      uint id = atomicAdd(draw_count[pass_id].count, 1);
      out_draws[draw_offset * 5 + id].index_count = vertex_count[2*i] * 3 / 2;
      out_draws[draw_offset * 5 + id].instance_count = 1;
      out_draws[draw_offset * 5 + id].first_index = vertex_offset * 3 / 2;
      out_draws[draw_offset * 5 + id].vertex_offset = d.first_vertex;
      out_draws[draw_offset * 5 + id].first_instance = d.first_instance;
    }
    vertex_offset += vertex_count[2*i];
    if (normal.z > 0.0) {
      uint id = atomicAdd(draw_count[pass_id].count, 1);
      out_draws[draw_offset * 5 + id].index_count = vertex_count[2*i+1] * 3 / 2;
      out_draws[draw_offset * 5 + id].instance_count = 1;
      out_draws[draw_offset * 5 + id].first_index = vertex_offset * 3 / 2;
      out_draws[draw_offset * 5 + id].vertex_offset = d.first_vertex;
      out_draws[draw_offset * 5 + id].first_instance = d.first_instance;
    }
    vertex_offset += vertex_count[2*i+1];
  }
#endif


#else
  vec3 dist = transform.position - camera_position;
  // backface culling
  uint num_added = 0;
  for (int i = 0; i < 6; i++) {
    vec3 normal = rotate(vox_normals[i], transform.rotation);
    if (dot(dist, normal) <= 0.01) {
      uint id = atomicAdd(draw_count[pass_id].count, 1);
      out_draws[draw_offset * 5 + id].index_count = vertex_count[i] * 3 / 2;
      out_draws[draw_offset * 5 + id].instance_count = 1;
      out_draws[draw_offset * 5 + id].first_index = vertex_offset * 3 / 2;
      out_draws[draw_offset * 5 + id].vertex_offset = d.first_vertex;
      out_draws[draw_offset * 5 + id].first_instance = d.first_instance;

      num_added++;
    }
    vertex_offset += vertex_count[i];
  }
#endif

  vertex_offset = d.first_vertex;
  vertex_counts[draw_offset + d.first_instance].count0 = vertex_offset + d.vertex_count0; vertex_offset += d.vertex_count0;
  vertex_counts[draw_offset + d.first_instance].count1 = vertex_offset + d.vertex_count1; vertex_offset += d.vertex_count1;
  vertex_counts[draw_offset + d.first_instance].count2 = vertex_offset + d.vertex_count2; vertex_offset += d.vertex_count2;
  vertex_counts[draw_offset + d.first_instance].count3 = vertex_offset + d.vertex_count3; vertex_offset += d.vertex_count3;
  vertex_counts[draw_offset + d.first_instance].count4 = vertex_offset + d.vertex_count4; vertex_offset += d.vertex_count4;

  // vertex_counts[draw_offset + d.first_instance].obb1_x = obb_corners[0].x;
  // vertex_counts[draw_offset + d.first_instance].obb1_y = obb_corners[0].y;
  // vertex_counts[draw_offset + d.first_instance].obb1_z = obb_corners[0].z;
  // vertex_counts[draw_offset + d.first_instance].obb2_x = obb_corners[7].x;
  // vertex_counts[draw_offset + d.first_instance].obb2_y = obb_corners[7].y;
  // vertex_counts[draw_offset + d.first_instance].obb2_z = obb_corners[7].z;
}
